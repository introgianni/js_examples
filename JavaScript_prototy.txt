function Model() {
    this.foo = "foo";
    this.array = [];
}

Model.prototype.foo = "";
Model.prototype.array = null;
Model.prototype.doNothing = function() {};

function RestModel() {
    this.bar = "bar";
}

RestModel.prototype = new Model;
RestModel.prototype.bar = ""

var myModel = new RestModel();

Now, here the issues:
PROBLEMI:
1)The constructor of Model is called once, only when the RestModel.prototype is set. Therefore, the foo property for every RestModel instance will be "foo".

2)Not only that, but all RestModel instances will share the same instance of the same array in this.array property. If you create an instance of Model directly, you have a new instance of array for each instances.

3)myModel.constructor is Model instead of RestModel. That's because we override prototype with a new instance of Model, that contains constructor equals to Model.

4)If you want to have a new instance of RestModel with a lazy call to the constructor, is not possible.
I think there are t

//////////////////////////////////////////

Per evitare l'array unico e di invocare un costruttore quando non serve:
si chiama ne costruttore il padre e usa la Object.create(modello.prototype)
function Model() {
    this.foo = "foo";
    this.array = [];
}

Model.prototype.foo = "";
Model.prototype.array = null;
Model.prototype.doNothing = function() {};

function RestModel() {
    Model.call(this);

    this.bar = "bar";
}

RestModel.prototype = Object.create(Model.prototype);
RestModel.prototype.constructor = RestModel;
RestModel.prototype.bar = ""

var myModel = new RestModel();

// for lazy constructor call
var anotherModel = Object.create(RestModel.prototype);

RestModel.call(anotherModel);




/////////////////////////////////Altro esempio: http://www.bennadel.com/log/2184-object-create-improves-constructor-based-inheritance-in-javascript---it-doesn-t-replace-it.htm////////////////////
<!DOCTYPE html>
<html>
<head>
    <title>Object.create() And Inheritance</title>
    <script type="text/javascript">
        // I am the person constructor.
       
        function Person( name ){
            // Store the property.
            this.name = name;
        }

        // Set up the class methods.
        Person.prototype.getName = function(){
            return( this.name );
        };
        // -------------------------------------------------- //
        // -------------------------------------------------- //
       
        // I am the girl constructor.
        function Girl( name ){
           
            // Call the super constructor.
            Person.call( this, name );
          
            // Create the traits property.
            this.traits = {};
        }

        // Extend the person prototype using Object.create(). Since
        // we are not actually creating an instance of person, we
        // don't have to worry about initialization - we simply
        // extend the Prototype of the Person and then we'll worry
        // about initialization later.

        Girl.prototype = Object.create( Person.prototype );
  
        
        // Create a girl instance.
        var sarah = new Girl( "Sarah" );
       
        // Set sarah's properties.
        sarah.traits.age = 30;
        sarah.traits.weight = 125;
       
        // Create a girl instance.
        var tricia = new Girl( "Tricia" );
       
        // Set tricia's properites.
        tricia.traits.age = 32;
        tricia.traits.weight = 140;
       
        // Log the girls' traits.
        console.log( sarah.getName(), sarah.traits );
        console.log( tricia.getName(), tricia.traits );
    </script>
</head>
<body>
    <!-- Left intentionally blank. -->
</body>
</html>


//////////altro esempio/////////////////////////////////////////////////////

ossiamo utilizzare il metodo Object.create() per creare il costruttore di un oggetto derivato. Ad esempio, se vogliamo creare il costruttore per un oggetto programmatore derivato da persona possiamo procedere come mostrato di seguito:

function programmatore(nome, cognome)
{
    persona.call(this, nome, cognome);
    this.linguaggiConosciuti = [];
}
 
programmatore.prototype = Object.create(persona.prototype);


Come possiamo vedere, abbiamo invocato la funzione che definisce il costruttore di persona tramite il metodo call() in modo tale da mappare un’istanza dell’oggetto persona sull’oggetto programmatore. In pratica, l’effetto che otteniamo è l’esecuzione del corpo della funzione persona() all’interno della funzione programmatore(), riportando di fatto su programmatore le inizializzazioni previste per persona. Aggiungiamo quindi a programmatore una nuova proprietà linguaggiConosciuti. Infine, tramite Object.create(), impostiamo il prototipo di programmatore facendolo puntare a quello di persona.